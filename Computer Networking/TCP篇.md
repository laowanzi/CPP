## TCP基本认识

![1310bf5ed78e4c8186481c47719e0793](C:\Users\Zhang Wan\Desktop\学习笔记\Computer Networking\Pictures\1310bf5ed78e4c8186481c47719e0793.webp)

![format,png-20230309230534096](C:\Users\Zhang Wan\Desktop\学习笔记\Computer Networking\Pictures\format,png-20230309230534096.webp)

**序列号**：建立连接时由计算机生成的随机数作为其初始值，通过SYN包传给接收端主机，每发送一次，就**累加**一次该**数据字节数**的大小，用来解决**网络包乱序**问题。

**确认问答号**：指下一次期望收到的数据的序列号，可以认为在这个序号之前的数据都已经被正常接收，用来解决**丢包**的问题。

**控制位**：

* ACK：该位为`1`时，**确认应答**的字段变为有效，TCP规定除了**最初建立连接时的`SYN`包**之外该位必须设置为`1`
* RST：该位为`1`时，表示TCP连接中出现异常必须强制断开连接
* SYN：该位为`1`时，表示希望建立连接，并在其**序列号**的字段进行序列号初始值的设定
* FIN：该位为`1`时，表示希望断开连接，通信双方互相交换`FIN`为1 的TCP段



### 什么是TCP

TCP是**面向连接的**、**可靠的**、**基于字节流**的传输层通信协议。

* **面向连接**：一对一
* **可靠的**：TCP保证一个报文能够到达接收端
* **字节流**：需要知道消息的边界

建立一个TCP连接需要双方达成三个信息的共识

* **Socket**：由IP地址（IP头部）和端口号（TCP头部）组成
* **序列号**：用来解决乱序问题等
* **窗口大小**：用来做流量控制



### UDP和TCP的区别

UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务，UDP头部格式如下：

![format,png-20230309230439961](C:\Users\Zhang Wan\Desktop\学习笔记\Computer Networking\Pictures\format,png-20230309230439961.webp)

区别：

1.连接

TCP是面向连接的，传输之前要先建立连接；UDP不需要连接

2.服务对象

TCP是一对一两点式服务的；UDP支持一对一，一对多和多对多的交互通信

3.可靠性

TCP是可靠的，数据可以无差错、不丢失、不重复、按序到达；

UDP是尽最大努力交付

4.拥塞控制，流量控制

TCP有以上机制，UDP则没有

5.首部开销

TCP首部一般是20个字节，使用选项字段会变长；UDP首部只有8个字节，且是固定的

6.传输方式

TCP是流式传输，没有边界，但保证顺序和可靠

UDP是一个包一个包的发送，是有边界的

7.分片不同

TCP的数据大小如果大于MSS大小，则在传输层进行分片，目标主机收到后同样在传输层进行组装

UDP的数据大小如果大于MTU大小，则会在IP层进行分片，目标主机收到后同样在IP层进行组装

8.应用场景不同：

TCP：FTP文件传输，HTTP/HTTPS

UDP：DNS、SNMP、视频音频等多媒体通信

## TCP连接建立

### TCP三次握手



#### ![TCP三次握手.drawio](C:\Users\Zhang Wan\Desktop\学习笔记\Computer Networking\Pictures\TCP三次握手.drawio.webp)

* 一开始，客户端和服务端都处于`CLOSE`状态。先是服务端主动监听某个接口，处于`LISTEN`状态

![format,png-20230309230500953](C:\Users\Zhang Wan\Desktop\学习笔记\Computer Networking\Pictures\format,png-20230309230500953.webp)

* 客户端随机初始化序列号（`client_isn`），将`SYN`标志位设为1，发送`SYN`包，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于`SYN-SENT`状态。



![format,png-20230309230504118](C:\Users\Zhang Wan\Desktop\学习笔记\Computer Networking\Pictures\format,png-20230309230504118.webp)

![format,png-20230309230508297](C:\Users\Zhang Wan\Desktop\学习笔记\Computer Networking\Pictures\format,png-20230309230508297.webp)

为什么需要三次握手

接下来，以三个方面分析三次握手的原因：

- 三次握手才可以阻止重复历史连接的初始化（主要原因）
- 三次握手才可以同步双方的初始序列号
- 三次握手才可以避免资源浪费

### 为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？

- 为了防止**历史报文被下一个相同四元组的连接接收**（主要方面）；
- 为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收；

### 第一次握手丢失了，会发生什么？

没有回应，超时重传，重传的SYN报文序列号不变，每次重传，超时等待时间是上一次的两倍。

### 第二次握手丢失了，会发生什么？

客户端收不到回应，触发超时重传；

服务端收不到回应，同样触发超时重传；

都超时重传

### 第三次握手丢失了，会发生什么？

服务端超时重传；

客户端不停回应。

在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：

- 半连接队列，也称 SYN 队列；
- 全连接队列，也称 accept 队列；

SYN 攻击方式最直接的表现就会把 TCP 半连接队列打满，这样**当 TCP 半连接队列满了，后续再在收到 SYN 报文就会丢弃**，导致客户端无法和服务端建立连接。

避免 SYN 攻击方式，可以有以下四种方法：

- 调大 netdev_max_backlog；先存起来，不放进半连接队列
- 增大 TCP 半连接队列；
- 开启 tcp_syncookies；绕开半连接队列
- 减少 SYN+ACK 重传次数。加快半连接队列的弹出速度





















## TCP连接断开

### TCP四次挥手

![format,png-20230309230614791](C:\Users\Zhang Wan\Desktop\学习笔记\Computer Networking\Pictures\format,png-20230309230614791.webp)



- 客户端打算关闭连接，此时会发送一个 TCP 首部 `FIN` 标志位被置为 `1` 的报文，也即 `FIN` 报文，之后客户端进入 `FIN_WAIT_1` 状态。
- 服务端收到该报文后，就向客户端发送 `ACK` 应答报文，接着服务端进入 `CLOSE_WAIT` 状态。
- 客户端收到服务端的 `ACK` 应答报文后，之后进入 `FIN_WAIT_2` 状态。
- 等待服务端处理完数据后，也向客户端发送 `FIN` 报文，之后服务端进入 `LAST_ACK` 状态。
- 客户端收到服务端的 `FIN` 报文后，回一个 `ACK` 应答报文，之后进入 `TIME_WAIT` 状态
- 服务端收到了 `ACK` 应答报文后，就进入了 `CLOSE` 状态，至此服务端已经完成连接的关闭。
- 客户端在经过 `2MSL` 一段时间后，自动进入 `CLOSE` 状态，至此客户端也完成连接的关闭。

你可以看到，每个方向都需要**一个 FIN 和一个 ACK**，因此通常被称为**四次挥手**。

这里一点需要注意是：**主动关闭连接的，才有 TIME_WAIT 状态。**



### 第一次挥手丢失了，会发生什么？

超时重传，达到一定次数，直接断开连接

### 第二次挥手丢失了，会发生什么？

客户端触发超时重传，服务端不停回应，达到一定次数，客户端断开连接





































