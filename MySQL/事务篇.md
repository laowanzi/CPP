## 事务篇

![eb15d4b6a9d543c1be4f7090479d969c](C:\Users\Zhang Wan\Desktop\学习笔记\MySQL\Pictures\eb15d4b6a9d543c1be4f7090479d969c.webp)

### 特性

* **原子性（Atomicity）**：一个事务中的所有操作，要么全部完成，要么全部不完成
* **一致性（Consistency）**：事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态
* **隔离性（Isolation）**：数据库允许多个并发事务同时对其数据进行读写和修改的能力
* **持久性（Durability）**：事务处理结束后，对数据的修改就是永久的

在`InnoDB`引擎中

* 持久性是通过redo log（重做日志）来保证的
* 原子性是通过undo log （回滚日志）来保证的
* 隔离性是通过MVCC（多版本并发控制）或锁机制来保证的
* 一致性通过持久性+原子性+隔离性来保证

### 并行事务会引发的问题

* **脏读**：一个事务读到了另一个未提交事务修改过的数据
* **不可重复读**：其他事务修改或删除了新的行，导致同一个查询语句返回的结果不同
* **幻读**：其他事务**插入**了新的行

### 事务的隔离级别

SQL标准提出四种隔离级别：

* **读未提交**（read uncommitted）：一个事务未提交时，其所做的改动就能被其他事务看到
* **读提交**（read committed）：一个事务提交后，其所做的改动才能被其他事务看到
* **可重复读**（repeatable read）：一个事务执行过程中看到的数据，和启动时看到的数据是一致的，这是`InnoDB`引擎的默认隔离级别
* **串行化**（serializable）：会对记录加上读写锁，事务发生冲突时，后访问的事务必须等前一个事务执行完成

不同的隔离级别能够解决不同的问题：

![4e98ea2e60923b969790898565b4d643](C:\Users\Zhang Wan\Desktop\学习笔记\MySQL\Pictures\4e98ea2e60923b969790898565b4d643.webp)

**InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象**，**解决的方案有两种**：

* 针对**快照读**（普通select语句）：通过**MVCC方式解决了幻读**
* 针对**当前读**（select...for update等语句），是通过**next-key lock（记录锁+间隙锁）方式解决了幻读**

这四种隔离级别具体是如何实现的呢？

- 对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；
- 对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；
- 对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 **Read View 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View。**

### Read View 在 MVCC 里如何工作的？

前置知识：

* Read View中四个字段的作用
* 聚簇记录中两个跟事务相关的隐藏列

![readview结构.drawio](C:\Users\Zhang Wan\Desktop\学习笔记\MySQL\Pictures\readview结构.drawio.webp)

![f595d13450878acd04affa82731f76c5](C:\Users\Zhang Wan\Desktop\学习笔记\MySQL\Pictures\f595d13450878acd04affa82731f76c5.webp)



一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：

- 如果记录的 trx_id 值小于 Read View 中的 `min_trx_id` 值，表示这个版本的记录是在创建 Read View **前**已经提交的事务生成的，所以该版本的记录对当前事务**可见**。
- 如果记录的 trx_id 值大于等于 Read View 中的 `max_trx_id` 值，表示这个版本的记录是在创建 Read View **后**才启动的事务生成的，所以该版本的记录对当前事务**不可见**。
- 如果记录的 trx_id 值在 Read View 的`min_trx_id` 和`max_trx_id`之间，需要判断 trx_id 是否在 m_ids 列表中：
  - 如果记录的 trx_id **在** `m_ids` 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务**不可见**。
  - 如果记录的 trx_id **不在** `m_ids`列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务**可见**。



































