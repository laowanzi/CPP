### 进程

***

**运行中**的程序，叫做进程。进程有着运行-暂停-运行的规律。

为了理解什么构成了进程，我们必须了解它的机器状态（**machine state**）

> 机器状态：程序在运行时可以读取或者更新的内容

进程的机器状态：它可以访问的内存（地址空间）、寄存器、程序计数器、外存

#### 进程的状态：

* 运行状态（*Running*）：该时刻进程占用CPU；
* 就绪状态（*Ready*）：可运行，等待别的进程退出运行状态
* 阻塞状态（*Blocked*）：不可运行
* 创建状态
* 结束状态

![进程状态变迁图](C:\Users\Zhang Wan\Desktop\学习笔记\OS\Pictures\8-进程五个状态.webp)

* 阻塞挂起状态：进程在外存并等待某个事件的出现
* 就绪挂起状态：进程在外存，只要进入内存，可以立刻运行



#### 进程的控制结构

### 多线程冲突

![2-提纲](C:\Users\Zhang Wan\Desktop\学习笔记\OS\Pictures\2-提纲.webp)

线程是调度的基本单位，进程则是资源分配的基本单位。

多个线程如果竞争共享资源，如果不采取有效的措施，则会造成共享数据的混乱。

![9-汇编语句-赋值过程-竞争](C:\Users\Zhang Wan\Desktop\学习笔记\OS\Pictures\9-汇编语句-赋值过程-竞争.webp)

#### 互斥的概念

上面展示的情况称为**竞争条件（race condition）**，当多线程互相竞争操作共享变量时，由于运气不好，在执行过程中发生了上下文切换，导致得到了错误的结果。输出的结果具有**不确定性（indeterminate）**。

由于多线程执行操作共享变量的这段代码可能会导致竞争状态，因此我们将这段代码称为临界区，它是访问共享资源的代码片段，一定不能给多线程同时执行。

所以我们希望这段代码是**互斥（mutualexclusion）**的，也就是保证一个线程在临界区执行的时候，其他线程应该被阻止进入临界区。

#### 同步的概念

所谓同步，就是并发线程/进程在一些关键电商可能需要混响等待与互通消息，这种相互制约的等待与互通消息称为进程同步。

![11-吃饭同步](C:\Users\Zhang Wan\Desktop\学习笔记\OS\Pictures\11-吃饭同步.webp)

#### 互斥与同步的实现与使用

主要方法有两个：

* 锁：加锁、解锁操作（针对互斥）
* 信号量：P、V操作

#### 锁

使用加锁操作和解锁操作可以解决并发线程/进程的互斥问题。

忙等待锁和无等待锁

#### 信号量



### 死锁

死锁产生的四个条件：互斥；持有并等待；非抢占；循环等待

#### 互斥条件

指的是多个线程不能同时使用同一个资源，要想使用，只能先等其他线程先释放资源

#### 持有并等待条件

线程持有了资源，又在等待其他资源，同时不会主动释放自己已经持有的资源

#### 不可剥夺条件

线程持有的资源不能被其他线程抢占

#### 循环等待条件

在死锁发生时，两个线程获取资源的顺序构成了环形链。

#### 如何避免死锁问题

要避免死锁问题，只要破坏其中一个条件即可，最常见的方法就是使用资源有序分配法来破坏环路等待条件。



### 锁

![锁之提纲](C:\Users\Zhang Wan\Desktop\学习笔记\OS\Pictures\锁之提纲.webp)

#### 互斥锁与自旋锁

这是最底层的两种锁，有很多高级的锁是基于它们实现的。

加锁的目的保证共享资源在任何一个时间内，最多只有一个线程访问，从而避免多线程访问导致数据错乱的问题。

当已经有一个线程加锁之后，其他线程加锁就会失败，互斥锁和自旋锁在加锁失败之后处理方法不同：

* 互斥锁加锁失败之后，线程会释放CPU，给其他线程
* 自旋锁加锁失败之后，会一直等待，占用CPU

对于互斥锁加锁失败而阻塞的情况，是由操作系统内核来实现的。当加锁失败是，内核会将线程置为睡眠，等到锁被释放后，内核会在合适的史记唤醒线程。

![互斥锁工作流程](C:\Users\Zhang Wan\Desktop\学习笔记\OS\Pictures\互斥锁工作流程.webp)

互斥锁加锁失败，会从用户态陷入内核态，有开销成本：**两次线程上下文切换的成本**。

如果被锁住的代码执行时间比较短，那就应该使用自旋锁，无需进行线程的上下文切换。

自旋锁是通过CPU提供的`CAS`函数（Compare And Swap），在用户态完成加锁和解锁操作。

#### 读写锁

由读锁和写锁两部分组成，适用于能明确区分读操作和写操作的场景。

联想到数据库中的读锁和写锁

#### 乐观锁和悲观锁

上文的互斥锁、自旋锁和读写锁，都是属于悲观锁

悲观锁比较悲观，他认为多线程同时修改共享资源的概率比较高，所以访问共享资源前，先要上锁。

乐观锁比较乐观，它的工作方式：先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成；否则放弃本次操作。

一个例子：在线文档的编辑





























